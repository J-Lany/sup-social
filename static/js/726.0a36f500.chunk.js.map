{"version":3,"file":"static/js/726.0a36f500.chunk.js","mappings":"oOACA,EAA4B,yBAA5B,EAAiE,yBAAjE,EAAqG,wBAArG,EAAoI,oBAApI,EAAiK,sBAAjK,EAAsM,4BAAtM,EAA0O,qBAA1O,EAA8Q,4BAA9Q,EAA0T,6BAA1T,EAA+V,qB,SC8C/V,EA5CgB,SAAHA,GAGT,IAH6F,IAA9EC,EAAcD,EAAdC,eAAgBC,EAAQF,EAARE,SAAUC,EAAWH,EAAXG,YAAaC,EAAaJ,EAAbI,cAAaC,EAAAL,EAAEM,YAAAA,OAAW,IAAAD,EAAG,GAAEA,EACjFE,EAAaC,KAAKC,KAAKR,EAAiBC,GACxCQ,EAAQ,GACHC,EAAI,EAAGA,GAAKJ,EAAYI,IAC7BD,EAAME,KAAKD,GAGf,IAAIE,EAAeL,KAAKC,KAAKF,EAAaD,GAC1CQ,GAAwCC,EAAAA,EAAAA,UAAS,GAAEC,GAAAC,EAAAA,EAAAA,GAAAH,EAAA,GAA9CI,EAAaF,EAAA,GAAEG,EAAgBH,EAAA,GAChCI,GAAqBF,EAAe,GAAKZ,EAAc,EACvDe,EAAqBH,EAAgBZ,EAEzC,OACIgB,EAAAA,EAAAA,KAAA,OAAAC,UACIC,EAAAA,EAAAA,MAAA,OAAKC,UAAWC,EAAcH,SAAA,CACzBL,EAAgB,IACbI,EAAAA,EAAAA,KAAA,UACAK,QAAS,WAAQR,EAAiBD,EAAgB,EAAG,EACrDO,UAAWC,EAAcH,SACxB,WACJb,EACIkB,QAAO,SAAAC,GACJ,OAAQA,GAAQT,GAAqBS,GAAQR,CACjD,IACCS,KAAI,SAACD,GAAI,OACNP,EAAAA,EAAAA,KAAA,QACIG,UAAWtB,IAAgB0B,GAAQH,EACnCC,QAAS,WAAQvB,EAAcyB,EAAM,EAAEN,SAGtCM,GAFIA,EAGF,IACdhB,EAAeK,IACZI,EAAAA,EAAAA,KAAA,UACAG,UAAWC,EACXC,QAAS,WAAQR,EAAiBD,EAAgB,EAAG,EAAEK,SACtD,eAMrB,E,mBCGA,EA3CW,SAAHvB,GAAyD,IAAnD+B,EAAI/B,EAAJ+B,KAAMC,EAAmBhC,EAAnBgC,oBAAqBC,EAAMjC,EAANiC,OAAQC,EAAQlC,EAARkC,SAE7C,OACIV,EAAAA,EAAAA,MAAA,OAAKC,UAAWC,EAAkBH,SAAA,EAC9BC,EAAAA,EAAAA,MAAA,OAAKC,UAAWC,EAAiBH,SAAA,EAC7BD,EAAAA,EAAAA,KAAA,OAAAC,UACID,EAAAA,EAAAA,KAACa,EAAAA,GAAO,CAACC,GAAI,YAAcL,EAAKM,GAAGd,UAC/BD,EAAAA,EAAAA,KAAA,OAAKG,UAAWC,EAAmBY,IAA0B,MAArBP,EAAKQ,OAAOC,MAAgBT,EAAKQ,OAAOC,MAAQC,EAAWC,IAAI,cAG/GpB,EAAAA,EAAAA,KAAA,OAAAC,SACKQ,EAAKY,UACArB,EAAAA,EAAAA,KAAA,UACEsB,SAAUZ,EAAoBa,MAAK,SAAAR,GAAE,OAAIA,IAAON,EAAKM,EAAE,IACvDV,QAAS,WAAQO,EAASH,EAAKM,GAAI,EACnCZ,UAAWC,EAAqBH,SAC/B,cAGHD,EAAAA,EAAAA,KAAA,UACEsB,SAAUZ,EAAoBa,MAAK,SAAAR,GAAE,OAAIA,IAAON,EAAKM,EAAE,IACvDV,QAAS,WAAQM,EAAOF,EAAKM,GAAI,EACjCZ,UAAWC,EAAsBH,SACpC,iBAMbC,EAAAA,EAAAA,MAAA,OAAAD,SAAA,EACIC,EAAAA,EAAAA,MAAA,QAAAD,SAAA,EACID,EAAAA,EAAAA,KAAA,OAAKG,UAAWC,EAAaH,SAAEQ,EAAKe,QACpCxB,EAAAA,EAAAA,KAAA,OAAKG,UAAWC,EAAeH,SAAEQ,EAAKgB,aAE1CvB,EAAAA,EAAAA,MAAA,QAAAD,SAAA,EACID,EAAAA,EAAAA,KAAA,OAAKG,UAAWC,EAAeH,SAAE,2BACjCD,EAAAA,EAAAA,KAAA,OAAKG,UAAWC,EAAeH,SAAE,+BAKrD,E,8DCpBA,EAtBY,SAAHvB,GAGL,IAHiF,IAAtEG,EAAWH,EAAXG,YAAaF,EAAcD,EAAdC,eAAgBC,EAAQF,EAARE,SAAUE,EAAaJ,EAAbI,cAAkB4C,GAAKC,EAAAA,EAAAA,GAAAjD,EAAAkD,GACrE3C,EAAaC,KAAKC,KAAKuC,EAAM/C,eAAiB+C,EAAM9C,UACpDQ,EAAQ,GACHC,EAAI,EAAGA,GAAKJ,EAAYI,IAC7BD,EAAME,KAAKD,GAEf,OACIa,EAAAA,EAAAA,MAAA,OAAAD,SAAA,EACID,EAAAA,EAAAA,KAAC6B,EAAS,CAAChD,YAAaA,EAAaD,SAAUA,EAAUD,eAAgBA,EAAgBG,cAAeA,IACtG4C,EAAMI,MAAMtB,KAAI,SAACC,GAAI,OACvBT,EAAAA,EAAAA,KAAC+B,EAAI,CAEDtB,KAAMA,EACNC,oBAAqBgB,EAAMhB,oBAC3BC,OAAQe,EAAMf,OACdC,SAAUc,EAAMd,UAJXH,EAAKM,GAKZ,MAId,E,kDCFO,SAASiB,EACdC,GAE8B,IAD9BC,EAAAC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,4CAAAG,cAA+DL,GAE/D,GAAoB,oBAATA,EACT,MAAM,IAAIM,UAAUL,EAExB,CAoDO,IAAMM,EAAgB,SAACC,GAC5B,OAAOC,MAAMC,QAAQF,GAAQA,EAAO,CAACA,EACvC,EASO,SAASG,EAAgBC,GAC9B,IAAMC,EAAeJ,MAAMC,QAAQE,EAAmB,IAClDA,EAAmB,GACnBA,EAOJ,OA9CK,SACLE,GAEiC,IADjCb,EAAAC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,gFAEA,IACGY,EAAMC,OAAM,SAACP,GAAA,MAA+C,oBAATA,CAAmB,IACvE,CACA,IAAMQ,EAAYF,EACfvC,KAAI,SAAAiC,GAAA,MACa,oBAATA,EAAS,YAAAH,OACAG,EAAKjB,MAAQ,uBAClBiB,CAAA,IAEZS,KAAK,MACR,MAAM,IAAIX,UAAA,GAAAD,OAAaJ,EAAA,KAAAI,OAAgBW,EAAA,KACzC,CACF,CAyBEE,CACEL,EAAA,kGAIKA,CACT,CC3FiCM,SAInBC,OAAOC,eAAe,CAAC,GCNrC,IAOMC,EACe,qBAAZC,QACHA,QATA,WACJ,SAAAC,EAAoBC,IAAUC,EAAAA,EAAAA,GAAA,KAAAF,GAAV,KAAAC,MAAAA,CAAW,CAG/B,OAH+BE,EAAAA,EAAAA,GAAAH,EAAA,EAAAI,IAAA,QAAAH,MAC/B,WACE,OAAOI,KAAKJ,KACd,KAAAD,CAAA,CAJI,GAYAM,EAAe,EACfC,EAAa,EA0CnB,SAASC,IACP,MAAO,CACLC,EAAGH,EACHI,OAAG,EACHC,EAAG,KACHC,EAAG,KAEP,CAmGO,SAASC,EACdrC,GAEA,IAIIsC,EALJC,EAAArC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAmD,CAAC,EAEhDsC,EAASR,IACLS,EAAwBF,EAAxBE,oBAIJC,EAAe,EAEnB,SAASC,IAGP,IAFA,IAAIC,EAAYJ,EAEPpF,EAAI,EAAGyF,EADG3C,UAAXC,OACoB/C,EAAIyF,EAAGzF,IAAK,CACtC,IAAM0F,EAAM5C,UAAU9C,GACtB,GACiB,oBAAR0F,GACS,kBAARA,GAA4B,OAARA,EAC5B,CAEA,IAAIC,EAAcH,EAAUT,EACR,OAAhBY,IACFH,EAAUT,EAAIY,EAAc,IAAIC,SAElC,IAAMC,EAAaF,EAAYG,IAAIJ,QAChB,IAAfG,GACFL,EAAYZ,IACZe,EAAYI,IAAIL,EAAKF,IAErBA,EAAYK,CAEhB,KAAO,CAEL,IAAIG,EAAiBR,EAAUR,EACR,OAAnBgB,IACFR,EAAUR,EAAIgB,EAAiB,IAAIC,KAErC,IAAMC,EAAgBF,EAAeF,IAAIJ,QACnB,IAAlBQ,GACFV,EAAYZ,IACZoB,EAAeD,IAAIL,EAAKF,IAExBA,EAAYU,CAEhB,CACF,CAEA,IAEIC,EAFEC,EAAiBZ,EAcvB,GAVIA,EAAUX,IAAMF,EAClBwB,EAASX,EAAUV,GAGnBqB,EAASvD,EAAKyD,MAAM,KAAMvD,WAC1BwC,KAGFc,EAAevB,EAAIF,EAEfU,EAAqB,KAAAiB,EAAAC,EACjBC,EAAoC,QAApCF,EAAkB,QAAlBC,EAAkBrB,SAAA,IAAAqB,OAAA,EAAAA,EAAYE,eAAM,IAAAH,EAAAA,EAAKpB,EAE1B,MAAnBsB,GACAnB,EAAoBmB,EAAqCL,KAEzDA,EAASK,EACQ,IAAjBlB,GAAsBA,KAMxBJ,EAFqB,kBAAXiB,GAAkC,OAAXA,GACb,oBAAXA,EACmB,IAAIjC,EAAIiC,GAAUA,CAChD,CAEA,OADAC,EAAetB,EAAIqB,EACZA,CACT,CAaA,OAXAZ,EAASmB,WAAa,WACpBtB,EAASR,IACTW,EAASoB,mBACX,EAEApB,EAASD,aAAe,kBAAMA,CAAA,EAE9BC,EAASoB,kBAAoB,WAC3BrB,EAAe,CACjB,EAEOC,CACT,CC1BO,SAASqB,EAUdC,GAOA,QAAAC,EAAAhE,UAAAC,OANGgE,EAAA,IAAA1D,MAAAyD,EAAA,EAAAA,EAAA,KAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAAAD,EAAAC,EAAA,GAAAlE,UAAAkE,GAQH,IAAMC,EAG0B,oBAArBJ,EACP,CACEK,QAASL,EACTM,eAAgBJ,GAElBF,EAiKJ,OA/JuB,WAgBlB,QAAAO,EAAAtE,UAAAC,OAVAS,EAAA,IAAAH,MAAA+D,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAA7D,EAAA6D,GAAAvE,UAAAuE,GAWH,IAEInC,EAFAoC,EAAiB,EACjBC,EAA2B,EAM3BC,EAKA,CAAC,EAGDC,EAAajE,EAAmBkE,MAUV,kBAAfD,IACTD,EAAwBC,EAExBA,EAAajE,EAAmBkE,OAGlC/E,EACE8E,EAAA,8EAAAxE,cACqFwE,EAAA,MAKvF,IAAME,GAAAC,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACDX,GACAO,GAIHN,EAKES,EALFT,QAAAW,EAKEF,EAJFR,eAAAA,OAAA,IAAAU,EAAiB,GAACA,EAAAC,EAIhBH,EAHFI,YAAAA,OAAA,IAAAD,EAAc7C,EAAA6C,EAAAE,EAGZL,EAFFM,mBAAAA,OAAA,IAAAD,EAAqB,GAACA,EASlBE,GAPFP,EADFQ,cAQ0BhF,EAAcgE,IACpCiB,EAA0BjF,EAAc8E,GACxCxE,EAAeF,EAAgBC,GAE/B6E,EAAqBnB,EAAAb,WAAA,GAAQ,WAIjC,OAHAiB,IAGQG,EAAgDpB,MACtD,KACAvD,UAEJ,GAAAG,QAAAqF,EAAAA,EAAAA,GAAMJ,KAMAK,EAAWR,EAAA1B,WAAA,GAAY,WAC3BkB,IAEA,IAAMiB,EHzPL,SACL/E,EACAgF,GAIA,IAFA,IAAMD,EAAuB,GACrBzF,EAAWU,EAAXV,OACC/C,EAAI,EAAGA,EAAI+C,EAAQ/C,IAG1BwI,EAAqBvI,KAAKwD,EAAazD,GAAGqG,MAAM,KAAMoC,IAExD,OAAOD,CACT,CG6OmCE,CAC3BjF,EACAX,WAiCF,OAFAoC,EAAamD,EAAmBhC,MAAM,KAAMmC,EAG9C,GAAAvF,QAAAqF,EAAAA,EAAAA,GAAMF,KAON,OAAOpE,OAAO2E,OAAOJ,EAAU,CAC7Bd,WAAAA,EACAY,mBAAAA,EACA5E,aAAAA,EACA8D,yBAA0B,kBAAMA,CAAA,EAChCqB,8BAA+B,WAC7BrB,EAA2B,CAC7B,EACArC,WAAY,kBAAMA,CAAA,EAClBoC,eAAgB,kBAAMA,CAAA,EACtBuB,oBAAqB,WACnBvB,EAAiB,CACnB,EACAJ,QAAAA,EACAa,YAAAA,GAOJ,CAKF,CAWO,IAAMe,EACKlC,EAAsB3B,GCvb3B8D,EAAe,SAACC,GAC3B,OAAOA,EAAMC,UAAUxG,KACzB,EAUayG,GAJeJ,EAAeC,GAAa,SAACtG,GACvD,OAAOA,EAAMxB,QAAO,SAAAkI,GAAC,OAAI,CAAI,GAC/B,IAE2B,SAACH,GAC1B,OAAOA,EAAMC,UAAU1J,QACzB,GAEa6J,EAAoB,SAACJ,GAChC,OAAOA,EAAMC,UAAU3J,cACzB,EAEa+J,EAAiB,SAACL,GAC7B,OAAOA,EAAMC,UAAUzJ,WACzB,EAEa8J,EAAsB,SAACN,GAClC,OAAOA,EAAMC,UAAUM,UACzB,EAEaC,EAAyB,SAACR,GACrC,OAAOA,EAAMC,UAAU5H,mBACzB,EC1BMoI,EAAc,SAAAC,IAAAC,EAAAA,EAAAA,GAAAF,EAAAC,GAAA,IAAAE,GAAAC,EAAAA,EAAAA,GAAAJ,GAAA,SAAAA,IAAA,IAAAK,GAAAxF,EAAAA,EAAAA,GAAA,KAAAmF,GAAA,QAAA3C,EAAAhE,UAAAC,OAAAgH,EAAA,IAAA1G,MAAAyD,GAAAkD,EAAA,EAAAA,EAAAlD,EAAAkD,IAAAD,EAAAC,GAAAlH,UAAAkH,GAQf,OAReF,EAAAF,EAAAK,KAAA5D,MAAAuD,EAAA,OAAA3G,OAAA8G,KAKhBtK,cAAgB,SAACyB,GACb4I,EAAKzH,MAAM6H,eAAehJ,GAC1B4I,EAAKzH,MAAM8H,SAASjJ,EAAM4I,EAAKzH,MAAM9C,SACzC,EAACuK,CAAA,CAgBA,OAhBAvF,EAAAA,EAAAA,GAAAkF,EAAA,EAAAjF,IAAA,oBAAAH,MAND,WACII,KAAKpC,MAAM8H,SAAS1F,KAAKpC,MAAM7C,YAAaiF,KAAKpC,MAAM9C,SAC3D,GAAC,CAAAiF,IAAA,SAAAH,MAKD,WAEI,OAAOxD,EAAAA,EAAAA,MAAAuJ,EAAAA,SAAA,CAAAxJ,SAAA,CACF6D,KAAKpC,MAAMkH,YAAa5I,EAAAA,EAAAA,KAAC0J,EAAAA,EAAS,IAAM,MACzC1J,EAAAA,EAAAA,KAAC2J,EAAK,CACFhL,eAAgBmF,KAAKpC,MAAM/C,eAC3BC,SAAUkF,KAAKpC,MAAM9C,SACrBC,YAAaiF,KAAKpC,MAAM7C,YACxBiD,MAAOgC,KAAKpC,MAAMI,MAClBhD,cAAegF,KAAKhF,cACpB8B,SAAUkD,KAAKpC,MAAMd,SACrBD,OAAQmD,KAAKpC,MAAMf,OACnBD,oBAAqBoD,KAAKpC,MAAMhB,wBAG5C,KAACoI,CAAA,CAxBe,CAASc,EAAAA,WAuC7B,GAAeC,EAAAA,EAAAA,KAXS,SAACxB,GACrB,MAAO,CACHvG,MAAOsG,EAAaC,GACpBzJ,SAAU2J,EAAYF,GACtB1J,eAAgB8J,EAAkBJ,GAClCxJ,YAAa6J,EAAeL,GAC5BO,WAAYD,EAAoBN,GAChC3H,oBAAqBmI,EAAuBR,GAEpD,GAII,CACI1H,OAAAA,EAAAA,GAAQC,SAAAA,EAAAA,GACR2I,eAAAA,EAAAA,GACAO,wBAAAA,EAAAA,GAAyBN,SAAAA,EAAAA,IALjC,CAMOV,E","sources":["webpack://my-app/./src/components/Users/Users.module.css?b9d0","components/Users/Paginator.jsx","components/Users/User.jsx","components/Users/Users.jsx","../node_modules/reselect/src/utils.ts","../node_modules/reselect/src/autotrackMemoize/proxy.ts","../node_modules/reselect/src/weakMapMemoize.ts","../node_modules/reselect/src/createSelectorCreator.ts","redux/usesrs-selectors.js","components/Users/UsersContainer.jsx"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"userPhoto\":\"Users_userPhoto__wCV7+\",\"userBlock\":\"Users_userBlock__KdI+p\",\"userLeft\":\"Users_userLeft__Stnn6\",\"name\":\"Users_name__85yu-\",\"status\":\"Users_status__2SZCL\",\"selectedPage\":\"Users_selectedPage__PbAMG\",\"pages\":\"Users_pages__R6hxo\",\"buttonFollow\":\"Users_buttonFollow__Yk2FG\",\"buttonUnollow\":\"Users_buttonUnollow__v0XTj\",\"arrow\":\"Users_arrow__6bVeM\"};","import React, { useState } from 'react';\nimport classes from './Users.module.css';\n\nlet Paginator = ({ totalUserCount, pageSize, currentPage, onPageChanged, portionSize = 10 }) => {\n    let pagesCount = Math.ceil(totalUserCount / pageSize);\n    let pages = [];\n    for (let i = 1; i <= pagesCount; i++) {\n        pages.push(i)\n    }\n\n    let portionCount = Math.ceil(pagesCount / portionSize);\n    let [portionNumber, setPortionNumber] = useState(1)\n    let leftPortionNumber = (portionNumber -1) * portionSize + 1;\n    let rightPortionNumber = portionNumber * portionSize;\n\n    return (\n        <div>\n            <div className={classes.pages}>\n                {portionNumber > 1 &&\n                    <button\n                    onClick={() => { setPortionNumber(portionNumber - 1) }}\n                    className={classes.arrow}\n                    >←</button>}\n                {pages\n                    .filter(page => {\n                        return (page >= leftPortionNumber && page <= rightPortionNumber)\n                    } )\n                    .map((page) =>\n                        <span\n                            className={currentPage === page && classes.selectedPage}\n                            onClick={() => { onPageChanged(page) }}\n                            key={page}\n                        >\n                            {page}\n                        </span>)}\n                {portionCount > portionNumber &&\n                    <button \n                    className={classes.arrow}\n                    onClick={() => { setPortionNumber(portionNumber + 1) }}\n                    >\n                        →\n                    </button>}\n            </div>\n        </div>\n    )\n}\n\nexport default Paginator;","import React from 'react';\nimport classes from './Users.module.css';\nimport userPhoto from '../../accets/images/defaultUserPhoto.jpg'\nimport { NavLink } from 'react-router-dom';\n\nlet User = ({ user, followingInProgress, follow, unfollow }) => {\n\n    return (\n        <div className={classes.userBlock}>\n            <div className={classes.userLeft}>\n                <div>\n                    <NavLink to={'/profile/' + user.id}>\n                        <img className={classes.userPhoto} src={user.photos.small != null ? user.photos.small : userPhoto} alt=\"avka\" />\n                    </NavLink>\n                </div>\n                <div>\n                    {user.followed\n                        ? <button\n                            disabled={followingInProgress.some(id => id === user.id)}\n                            onClick={() => { unfollow(user.id) }}\n                            className={classes.buttonFollow}\n                            >\n                            Unfollow\n                        </button>\n                        : <button\n                            disabled={followingInProgress.some(id => id === user.id)}\n                            onClick={() => { follow(user.id) }}\n                            className={classes.buttonUnollow}\n                        >\n                            Follow\n                        </button>\n                    }\n                </div>\n            </div>\n            <div>\n                <span>\n                    <div className={classes.name}>{user.name}</div>\n                    <div className={classes.status}>{user.status}</div>\n                </span>\n                <span>\n                    <div className={classes.status}>{\"user.location.country\"}</div>\n                    <div className={classes.status}>{\"user.location.city\"}</div>\n                </span>\n            </div>\n        </div>\n    )\n}\n\nexport default User;","import React from 'react';\nimport Paginator from './Paginator';\nimport User from './User'\n\nlet Users = ({ currentPage, totalUserCount, pageSize, onPageChanged, ...props }) => {\n    let pagesCount = Math.ceil(props.totalUserCount / props.pageSize);\n    let pages = [];\n    for (let i = 1; i <= pagesCount; i++) {\n        pages.push(i)\n    }\n    return (\n        <div>\n            <Paginator currentPage={currentPage} pageSize={pageSize} totalUserCount={totalUserCount} onPageChanged={onPageChanged} />\n            { props.users.map((user) => \n            <User\n                key={user.id}\n                user={user}\n                followingInProgress={props.followingInProgress}\n                follow={props.follow}\n                unfollow={props.unfollow}\n            />\n            )}\n        </ div>\n    )\n}\n\nexport default Users;","import { runIdentityFunctionCheck } from './devModeChecks/identityFunctionCheck'\r\nimport { runInputStabilityCheck } from './devModeChecks/inputStabilityCheck'\r\nimport { globalDevModeChecks } from './devModeChecks/setGlobalDevModeChecks'\r\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\r\nimport type {\r\n  DevModeChecks,\r\n  Selector,\r\n  SelectorArray,\r\n  DevModeChecksExecutionInfo\r\n} from './types'\r\n\r\nexport const NOT_FOUND = 'NOT_FOUND'\r\nexport type NOT_FOUND_TYPE = typeof NOT_FOUND\r\n\r\n/**\r\n * Assert that the provided value is a function. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param func - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsFunction<FunctionType extends Function>(\r\n  func: unknown,\r\n  errorMessage = `expected a function, instead received ${typeof func}`\r\n): asserts func is FunctionType {\r\n  if (typeof func !== 'function') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided value is an object. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param object - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsObject<ObjectType extends Record<string, unknown>>(\r\n  object: unknown,\r\n  errorMessage = `expected an object, instead received ${typeof object}`\r\n): asserts object is ObjectType {\r\n  if (typeof object !== 'object') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided array is an array of functions. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param array - The array to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsArrayOfFunctions<FunctionType extends Function>(\r\n  array: unknown[],\r\n  errorMessage = `expected all items to be functions, instead received the following types: `\r\n): asserts array is FunctionType[] {\r\n  if (\r\n    !array.every((item): item is FunctionType => typeof item === 'function')\r\n  ) {\r\n    const itemTypes = array\r\n      .map(item =>\r\n        typeof item === 'function'\r\n          ? `function ${item.name || 'unnamed'}()`\r\n          : typeof item\r\n      )\r\n      .join(', ')\r\n    throw new TypeError(`${errorMessage}[${itemTypes}]`)\r\n  }\r\n}\r\n\r\n/**\r\n * Ensure that the input is an array. If it's already an array, it's returned as is.\r\n * If it's not an array, it will be wrapped in a new array.\r\n *\r\n * @param item - The item to be checked.\r\n * @returns An array containing the input item. If the input is already an array, it's returned without modification.\r\n */\r\nexport const ensureIsArray = (item: unknown) => {\r\n  return Array.isArray(item) ? item : [item]\r\n}\r\n\r\n/**\r\n * Extracts the \"dependencies\" / \"input selectors\" from the arguments of `createSelector`.\r\n *\r\n * @param createSelectorArgs - Arguments passed to `createSelector` as an array.\r\n * @returns An array of \"input selectors\" / \"dependencies\".\r\n * @throws A `TypeError` if any of the input selectors is not function.\r\n */\r\nexport function getDependencies(createSelectorArgs: unknown[]) {\r\n  const dependencies = Array.isArray(createSelectorArgs[0])\r\n    ? createSelectorArgs[0]\r\n    : createSelectorArgs\r\n\r\n  assertIsArrayOfFunctions<Selector>(\r\n    dependencies,\r\n    `createSelector expects all input-selectors to be functions, but received the following types: `\r\n  )\r\n\r\n  return dependencies as SelectorArray\r\n}\r\n\r\n/**\r\n * Runs each input selector and returns their collective results as an array.\r\n *\r\n * @param dependencies - An array of \"dependencies\" or \"input selectors\".\r\n * @param inputSelectorArgs - An array of arguments being passed to the input selectors.\r\n * @returns An array of input selector results.\r\n */\r\nexport function collectInputSelectorResults(\r\n  dependencies: SelectorArray,\r\n  inputSelectorArgs: unknown[] | IArguments\r\n) {\r\n  const inputSelectorResults = []\r\n  const { length } = dependencies\r\n  for (let i = 0; i < length; i++) {\r\n    // @ts-ignore\r\n    // apply arguments instead of spreading and mutate a local list of params for performance.\r\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs))\r\n  }\r\n  return inputSelectorResults\r\n}\r\n\r\n/**\r\n * Retrieves execution information for development mode checks.\r\n *\r\n * @param devModeChecks - Custom Settings for development mode checks. These settings will override the global defaults.\r\n * @param firstRun - Indicates whether it is the first time the selector has run.\r\n * @returns  An object containing the execution information for each development mode check.\r\n */\r\nexport const getDevModeChecksExecutionInfo = (\r\n  firstRun: boolean,\r\n  devModeChecks: Partial<DevModeChecks>\r\n) => {\r\n  const { identityFunctionCheck, inputStabilityCheck } = {\r\n    ...globalDevModeChecks,\r\n    ...devModeChecks\r\n  }\r\n  return {\r\n    identityFunctionCheck: {\r\n      shouldRun:\r\n        identityFunctionCheck === 'always' ||\r\n        (identityFunctionCheck === 'once' && firstRun),\r\n      run: runIdentityFunctionCheck\r\n    },\r\n    inputStabilityCheck: {\r\n      shouldRun:\r\n        inputStabilityCheck === 'always' ||\r\n        (inputStabilityCheck === 'once' && firstRun),\r\n      run: runInputStabilityCheck\r\n    }\r\n  } satisfies DevModeChecksExecutionInfo\r\n}\r\n","// Original source:\r\n// - https://github.com/simonihmig/tracked-redux/blob/master/packages/tracked-redux/src/-private/proxy.ts\r\n\r\nimport type { Node, Tag } from './tracking'\r\nimport {\r\n  consumeCollection,\r\n  consumeTag,\r\n  createTag,\r\n  dirtyCollection,\r\n  dirtyTag\r\n} from './tracking'\r\n\r\nexport const REDUX_PROXY_LABEL = Symbol()\r\n\r\nlet nextId = 0\r\n\r\nconst proto = Object.getPrototypeOf({})\r\n\r\nclass ObjectTreeNode<T extends Record<string, unknown>> implements Node<T> {\r\n  proxy: T = new Proxy(this, objectProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {} as Record<string, Tag>\r\n  children = {} as Record<string, Node>\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst objectProxyHandler = {\r\n  get(node: Node, key: string | symbol): unknown {\r\n    function calculateResult() {\r\n      const { value } = node\r\n\r\n      const childValue = Reflect.get(value, key)\r\n\r\n      if (typeof key === 'symbol') {\r\n        return childValue\r\n      }\r\n\r\n      if (key in proto) {\r\n        return childValue\r\n      }\r\n\r\n      if (typeof childValue === 'object' && childValue !== null) {\r\n        let childNode = node.children[key]\r\n\r\n        if (childNode === undefined) {\r\n          childNode = node.children[key] = createNode(childValue)\r\n        }\r\n\r\n        if (childNode.tag) {\r\n          consumeTag(childNode.tag)\r\n        }\r\n\r\n        return childNode.proxy\r\n      } else {\r\n        let tag = node.tags[key]\r\n\r\n        if (tag === undefined) {\r\n          tag = node.tags[key] = createTag()\r\n          tag.value = childValue\r\n        }\r\n\r\n        consumeTag(tag)\r\n\r\n        return childValue\r\n      }\r\n    }\r\n    const res = calculateResult()\r\n    return res\r\n  },\r\n\r\n  ownKeys(node: Node): ArrayLike<string | symbol> {\r\n    consumeCollection(node)\r\n    return Reflect.ownKeys(node.value)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    node: Node,\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return Reflect.getOwnPropertyDescriptor(node.value, prop)\r\n  },\r\n\r\n  has(node: Node, prop: string | symbol): boolean {\r\n    return Reflect.has(node.value, prop)\r\n  }\r\n}\r\n\r\nclass ArrayTreeNode<T extends Array<unknown>> implements Node<T> {\r\n  proxy: T = new Proxy([this], arrayProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {}\r\n  children = {}\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst arrayProxyHandler = {\r\n  get([node]: [Node], key: string | symbol): unknown {\r\n    if (key === 'length') {\r\n      consumeCollection(node)\r\n    }\r\n\r\n    return objectProxyHandler.get(node, key)\r\n  },\r\n\r\n  ownKeys([node]: [Node]): ArrayLike<string | symbol> {\r\n    return objectProxyHandler.ownKeys(node)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    [node]: [Node],\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop)\r\n  },\r\n\r\n  has([node]: [Node], prop: string | symbol): boolean {\r\n    return objectProxyHandler.has(node, prop)\r\n  }\r\n}\r\n\r\nexport function createNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  value: T\r\n): Node<T> {\r\n  if (Array.isArray(value)) {\r\n    return new ArrayTreeNode(value)\r\n  }\r\n\r\n  return new ObjectTreeNode(value) as Node<T>\r\n}\r\n\r\nconst keysMap = new WeakMap<\r\n  Array<unknown> | Record<string, unknown>,\r\n  Set<string>\r\n>()\r\n\r\nexport function updateNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  node: Node<T>,\r\n  newValue: T\r\n): void {\r\n  const { value, tags, children } = node\r\n\r\n  node.value = newValue\r\n\r\n  if (\r\n    Array.isArray(value) &&\r\n    Array.isArray(newValue) &&\r\n    value.length !== newValue.length\r\n  ) {\r\n    dirtyCollection(node)\r\n  } else {\r\n    if (value !== newValue) {\r\n      let oldKeysSize = 0\r\n      let newKeysSize = 0\r\n      let anyKeysAdded = false\r\n\r\n      for (const _key in value) {\r\n        oldKeysSize++\r\n      }\r\n\r\n      for (const key in newValue) {\r\n        newKeysSize++\r\n        if (!(key in value)) {\r\n          anyKeysAdded = true\r\n          break\r\n        }\r\n      }\r\n\r\n      const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize\r\n\r\n      if (isDifferent) {\r\n        dirtyCollection(node)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const key in tags) {\r\n    const childValue = (value as Record<string, unknown>)[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    if (childValue !== newChildValue) {\r\n      dirtyCollection(node)\r\n      dirtyTag(tags[key], newChildValue)\r\n    }\r\n\r\n    if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      delete tags[key]\r\n    }\r\n  }\r\n\r\n  for (const key in children) {\r\n    const childNode = children[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    const childValue = childNode.value\r\n\r\n    if (childValue === newChildValue) {\r\n      continue\r\n    } else if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      updateNode(childNode, newChildValue as Record<string, unknown>)\r\n    } else {\r\n      deleteNode(childNode)\r\n      delete children[key]\r\n    }\r\n  }\r\n}\r\n\r\nfunction deleteNode(node: Node): void {\r\n  if (node.tag) {\r\n    dirtyTag(node.tag, null)\r\n  }\r\n  dirtyCollection(node)\r\n  for (const key in node.tags) {\r\n    dirtyTag(node.tags[key], null)\r\n  }\r\n  for (const key in node.children) {\r\n    deleteNode(node.children[key])\r\n  }\r\n}\r\n","// Original source:\r\n// - https://github.com/facebook/react/blob/0b974418c9a56f6c560298560265dcf4b65784bc/packages/react/src/ReactCache.js\r\n\r\nimport type {\r\n  AnyFunction,\r\n  DefaultMemoizeFields,\r\n  EqualityFn,\r\n  Simplify\r\n} from './types'\r\n\r\nclass StrongRef<T> {\r\n  constructor(private value: T) {}\r\n  deref() {\r\n    return this.value\r\n  }\r\n}\r\n\r\nconst Ref =\r\n  typeof WeakRef !== 'undefined'\r\n    ? WeakRef\r\n    : (StrongRef as unknown as typeof WeakRef)\r\n\r\nconst UNTERMINATED = 0\r\nconst TERMINATED = 1\r\n\r\ninterface UnterminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 0\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: void\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular Map where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ninterface TerminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 1\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: T\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular `Map` where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ntype CacheNode<T> = TerminatedCacheNode<T> | UnterminatedCacheNode<T>\r\n\r\nfunction createCacheNode<T>(): CacheNode<T> {\r\n  return {\r\n    s: UNTERMINATED,\r\n    v: undefined,\r\n    o: null,\r\n    p: null\r\n  }\r\n}\r\n\r\n/**\r\n * Configuration options for a memoization function utilizing `WeakMap` for\r\n * its caching mechanism.\r\n *\r\n * @template Result - The type of the return value of the memoized function.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport interface WeakMapMemoizeOptions<Result = any> {\r\n  /**\r\n   * If provided, used to compare a newly generated output value against previous values in the cache.\r\n   * If a match is found, the old value is returned. This addresses the common\r\n   * ```ts\r\n   * todos.map(todo => todo.id)\r\n   * ```\r\n   * use case, where an update to another field in the original data causes a recalculation\r\n   * due to changed references, but the output is still effectively the same.\r\n   *\r\n   * @since 5.0.0\r\n   */\r\n  resultEqualityCheck?: EqualityFn<Result>\r\n}\r\n\r\n/**\r\n * Creates a tree of `WeakMap`-based cache nodes based on the identity of the\r\n * arguments it's been called with (in this case, the extracted values from your input selectors).\r\n * This allows `weakMapMemoize` to have an effectively infinite cache size.\r\n * Cache results will be kept in memory as long as references to the arguments still exist,\r\n * and then cleared out as the arguments are garbage-collected.\r\n *\r\n * __Design Tradeoffs for `weakMapMemoize`:__\r\n * - Pros:\r\n *   - It has an effectively infinite cache size, but you have no control over\r\n *   how long values are kept in cache as it's based on garbage collection and `WeakMap`s.\r\n * - Cons:\r\n *   - There's currently no way to alter the argument comparisons.\r\n *   They're based on strict reference equality.\r\n *   - It's roughly the same speed as `lruMemoize`, although likely a fraction slower.\r\n *\r\n * __Use Cases for `weakMapMemoize`:__\r\n * - This memoizer is likely best used for cases where you need to call the\r\n * same selector instance with many different arguments, such as a single\r\n * selector instance that is used in a list item component and called with\r\n * item IDs like:\r\n *   ```ts\r\n *   useSelector(state => selectSomeData(state, props.category))\r\n *   ```\r\n * @param func - The function to be memoized.\r\n * @returns A memoized function with a `.clearCache()` method attached.\r\n *\r\n * @example\r\n * <caption>Using `createSelector`</caption>\r\n * ```ts\r\n * import { createSelector, weakMapMemoize } from 'reselect'\r\n *\r\n * interface RootState {\r\n *   items: { id: number; category: string; name: string }[]\r\n * }\r\n *\r\n * const selectItemsByCategory = createSelector(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category),\r\n *   {\r\n *     memoize: weakMapMemoize,\r\n *     argsMemoize: weakMapMemoize\r\n *   }\r\n * )\r\n * ```\r\n *\r\n * @example\r\n * <caption>Using `createSelectorCreator`</caption>\r\n * ```ts\r\n * import { createSelectorCreator, weakMapMemoize } from 'reselect'\r\n *\r\n * const createSelectorWeakMap = createSelectorCreator({ memoize: weakMapMemoize, argsMemoize: weakMapMemoize })\r\n *\r\n * const selectItemsByCategory = createSelectorWeakMap(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category)\r\n * )\r\n * ```\r\n *\r\n * @template Func - The type of the function that is memoized.\r\n *\r\n * @see {@link https://reselect.js.org/api/weakMapMemoize `weakMapMemoize`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n * @experimental\r\n */\r\nexport function weakMapMemoize<Func extends AnyFunction>(\r\n  func: Func,\r\n  options: WeakMapMemoizeOptions<ReturnType<Func>> = {}\r\n) {\r\n  let fnNode = createCacheNode()\r\n  const { resultEqualityCheck } = options\r\n\r\n  let lastResult: WeakRef<object> | undefined\r\n\r\n  let resultsCount = 0\r\n\r\n  function memoized() {\r\n    let cacheNode = fnNode\r\n    const { length } = arguments\r\n    for (let i = 0, l = length; i < l; i++) {\r\n      const arg = arguments[i]\r\n      if (\r\n        typeof arg === 'function' ||\r\n        (typeof arg === 'object' && arg !== null)\r\n      ) {\r\n        // Objects go into a WeakMap\r\n        let objectCache = cacheNode.o\r\n        if (objectCache === null) {\r\n          cacheNode.o = objectCache = new WeakMap()\r\n        }\r\n        const objectNode = objectCache.get(arg)\r\n        if (objectNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          objectCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = objectNode\r\n        }\r\n      } else {\r\n        // Primitives go into a regular Map\r\n        let primitiveCache = cacheNode.p\r\n        if (primitiveCache === null) {\r\n          cacheNode.p = primitiveCache = new Map()\r\n        }\r\n        const primitiveNode = primitiveCache.get(arg)\r\n        if (primitiveNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          primitiveCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = primitiveNode\r\n        }\r\n      }\r\n    }\r\n\r\n    const terminatedNode = cacheNode as unknown as TerminatedCacheNode<any>\r\n\r\n    let result\r\n\r\n    if (cacheNode.s === TERMINATED) {\r\n      result = cacheNode.v\r\n    } else {\r\n      // Allow errors to propagate\r\n      result = func.apply(null, arguments as unknown as any[])\r\n      resultsCount++\r\n    }\r\n\r\n    terminatedNode.s = TERMINATED\r\n\r\n    if (resultEqualityCheck) {\r\n      const lastResultValue = lastResult?.deref() ?? lastResult\r\n      if (\r\n        lastResultValue != null &&\r\n        resultEqualityCheck(lastResultValue as ReturnType<Func>, result)\r\n      ) {\r\n        result = lastResultValue\r\n        resultsCount !== 0 && resultsCount--\r\n      }\r\n\r\n      const needsWeakRef =\r\n        (typeof result === 'object' && result !== null) ||\r\n        typeof result === 'function'\r\n      lastResult = needsWeakRef ? new Ref(result) : result\r\n    }\r\n    terminatedNode.v = result\r\n    return result\r\n  }\r\n\r\n  memoized.clearCache = () => {\r\n    fnNode = createCacheNode()\r\n    memoized.resetResultsCount()\r\n  }\r\n\r\n  memoized.resultsCount = () => resultsCount\r\n\r\n  memoized.resetResultsCount = () => {\r\n    resultsCount = 0\r\n  }\r\n\r\n  return memoized as Func & Simplify<DefaultMemoizeFields>\r\n}\r\n","import { weakMapMemoize } from './weakMapMemoize'\r\n\r\nimport type {\r\n  Combiner,\r\n  CreateSelectorOptions,\r\n  DropFirstParameter,\r\n  ExtractMemoizerFields,\r\n  GetParamsFromSelectors,\r\n  GetStateFromSelectors,\r\n  InterruptRecursion,\r\n  OutputSelector,\r\n  Selector,\r\n  SelectorArray,\r\n  SetRequired,\r\n  Simplify,\r\n  UnknownMemoizer\r\n} from './types'\r\n\r\nimport {\r\n  assertIsFunction,\r\n  collectInputSelectorResults,\r\n  ensureIsArray,\r\n  getDependencies,\r\n  getDevModeChecksExecutionInfo\r\n} from './utils'\r\n\r\n/**\r\n * An instance of `createSelector`, customized with a given memoize implementation.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n *\r\n * @public\r\n */\r\nexport interface CreateSelectorFunction<\r\n  MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n> {\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments and a `combiner` function.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://github.com/reduxjs/reselect#createselectorinputselectors--inputselectors-resultfunc-createselectoroptions createSelector}\r\n   */\r\n  <InputSelectors extends SelectorArray, Result>(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments, a `combiner` function and an `options` object.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://github.com/reduxjs/reselect#createselectorinputselectors--inputselectors-resultfunc-createselectoroptions createSelector}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions: Simplify<\r\n        CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n      >\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param inputSelectors - An array of input selectors.\r\n   * @param combiner - A function that Combines the input selectors and returns an output selector. Otherwise known as the result function.\r\n   * @param createSelectorOptions - An optional options object that allows for further customization per selector.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://github.com/reduxjs/reselect#createselectorinputselectors--inputselectors-resultfunc-createselectoroptions createSelector}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    inputSelectors: [...InputSelectors],\r\n    combiner: Combiner<InputSelectors, Result>,\r\n    createSelectorOptions?: Simplify<\r\n      CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    >\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n}\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param options - An options object containing the `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). It also provides additional options for customizing memoization. While the `memoize` property is mandatory, the rest are optional.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator({\r\n *   memoize: customMemoize, // Function to be used to memoize `resultFunc`\r\n *   memoizeOptions: [memoizeOption1, memoizeOption2], // Options passed to `customMemoize` as the second argument onwards\r\n *   argsMemoize: customArgsMemoize, // Function to be used to memoize the selector's arguments\r\n *   argsMemoizeOptions: [argsMemoizeOption1, argsMemoizeOption2] // Options passed to `customArgsMemoize` as the second argument onwards\r\n * })\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n *\r\n * customSelector(\r\n *   ...selectorArgs // Will be memoized by `customArgsMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-options-since-500 `createSelectorCreator`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n>(\r\n  options: Simplify<\r\n    SetRequired<\r\n      CreateSelectorOptions<\r\n        typeof weakMapMemoize,\r\n        typeof weakMapMemoize,\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      >,\r\n      'memoize'\r\n    >\r\n  >\r\n): CreateSelectorFunction<MemoizeFunction, ArgsMemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param memoize - The `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator(customMemoize, // Function to be used to memoize `resultFunc`\r\n *   option1, // Will be passed as second argument to `customMemoize`\r\n *   option2, // Will be passed as third argument to `customMemoize`\r\n *   option3 // Will be passed as fourth argument to `customMemoize`\r\n * )\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-memoize-and-memoizeoptions `createSelectorCreator`}\r\n *\r\n * @public\r\n */\r\nexport function createSelectorCreator<MemoizeFunction extends UnknownMemoizer>(\r\n  memoize: MemoizeFunction,\r\n  ...memoizeOptionsFromArgs: DropFirstParameter<MemoizeFunction>\r\n): CreateSelectorFunction<MemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function and options for customizing memoization behavior.\r\n *\r\n * @param memoizeOrOptions - Either A `memoize` function or an `options` object containing the `memoize` function.\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n * @template MemoizeOrOptions - The type of the first argument. It can either be a `memoize` function or an `options` object containing the `memoize` function.\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer,\r\n  MemoizeOrOptions extends\r\n    | MemoizeFunction\r\n    | SetRequired<\r\n        CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n        'memoize'\r\n      >\r\n>(\r\n  memoizeOrOptions: MemoizeOrOptions,\r\n  ...memoizeOptionsFromArgs: MemoizeOrOptions extends SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  >\r\n    ? never\r\n    : DropFirstParameter<MemoizeFunction>\r\n) {\r\n  /** options initially passed into `createSelectorCreator`. */\r\n  const createSelectorCreatorOptions: SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  > = typeof memoizeOrOptions === 'function'\r\n    ? {\r\n        memoize: memoizeOrOptions as MemoizeFunction,\r\n        memoizeOptions: memoizeOptionsFromArgs\r\n      }\r\n    : memoizeOrOptions\r\n\r\n  const createSelector = <\r\n    InputSelectors extends SelectorArray,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: [...InputSelectors],\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions?: CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    ]\r\n  ) => {\r\n    let recomputations = 0\r\n    let dependencyRecomputations = 0\r\n    let lastResult: Result\r\n\r\n    // Due to the intricacies of rest params, we can't do an optional arg after `...createSelectorArgs`.\r\n    // So, start by declaring the default value here.\r\n    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)\r\n    let directlyPassedOptions: CreateSelectorOptions<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    > = {}\r\n\r\n    // Normally, the result func or \"combiner\" is the last arg\r\n    let resultFunc = createSelectorArgs.pop() as\r\n      | Combiner<InputSelectors, Result>\r\n      | CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n\r\n    // If the result func is actually an _object_, assume it's our options object\r\n    if (typeof resultFunc === 'object') {\r\n      directlyPassedOptions = resultFunc\r\n      // and pop the real result func off\r\n      resultFunc = createSelectorArgs.pop() as Combiner<InputSelectors, Result>\r\n    }\r\n\r\n    assertIsFunction(\r\n      resultFunc,\r\n      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`\r\n    )\r\n\r\n    // Determine which set of options we're using. Prefer options passed directly,\r\n    // but fall back to options given to `createSelectorCreator`.\r\n    const combinedOptions = {\r\n      ...createSelectorCreatorOptions,\r\n      ...directlyPassedOptions\r\n    }\r\n\r\n    const {\r\n      memoize,\r\n      memoizeOptions = [],\r\n      argsMemoize = weakMapMemoize,\r\n      argsMemoizeOptions = [],\r\n      devModeChecks = {}\r\n    } = combinedOptions\r\n\r\n    // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer\r\n    // is an array. In most libs I've looked at, it's an equality function or options object.\r\n    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full\r\n    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so\r\n    // we wrap it in an array so we can apply it.\r\n    const finalMemoizeOptions = ensureIsArray(memoizeOptions)\r\n    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions)\r\n    const dependencies = getDependencies(createSelectorArgs) as InputSelectors\r\n\r\n    const memoizedResultFunc = memoize(function recomputationWrapper() {\r\n      recomputations++\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      return (resultFunc as Combiner<InputSelectors, Result>).apply(\r\n        null,\r\n        arguments\r\n      )\r\n    }, ...finalMemoizeOptions) as Combiner<InputSelectors, Result> &\r\n      ExtractMemoizerFields<OverrideMemoizeFunction>\r\n\r\n    let firstRun = true\r\n\r\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\r\n    const selector = argsMemoize(function dependenciesChecker() {\r\n      dependencyRecomputations++\r\n      /** Return values of input selectors which the `resultFunc` takes as arguments. */\r\n      const inputSelectorResults = collectInputSelectorResults(\r\n        dependencies,\r\n        arguments\r\n      )\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        const { identityFunctionCheck, inputStabilityCheck } =\r\n          getDevModeChecksExecutionInfo(firstRun, devModeChecks)\r\n        if (identityFunctionCheck.shouldRun) {\r\n          identityFunctionCheck.run(\r\n            resultFunc as Combiner<InputSelectors, Result>\r\n          )\r\n        }\r\n\r\n        if (inputStabilityCheck.shouldRun) {\r\n          // make a second copy of the params, to check if we got the same results\r\n          const inputSelectorResultsCopy = collectInputSelectorResults(\r\n            dependencies,\r\n            arguments\r\n          )\r\n\r\n          inputStabilityCheck.run(\r\n            { inputSelectorResults, inputSelectorResultsCopy },\r\n            { memoize, memoizeOptions: finalMemoizeOptions },\r\n            arguments\r\n          )\r\n        }\r\n\r\n        if (firstRun) firstRun = false\r\n      }\r\n\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      lastResult = memoizedResultFunc.apply(null, inputSelectorResults)\r\n\r\n      return lastResult\r\n    }, ...finalArgsMemoizeOptions) as unknown as Selector<\r\n      GetStateFromSelectors<InputSelectors>,\r\n      Result,\r\n      GetParamsFromSelectors<InputSelectors>\r\n    > &\r\n      ExtractMemoizerFields<OverrideArgsMemoizeFunction>\r\n\r\n    return Object.assign(selector, {\r\n      resultFunc,\r\n      memoizedResultFunc,\r\n      dependencies,\r\n      dependencyRecomputations: () => dependencyRecomputations,\r\n      resetDependencyRecomputations: () => {\r\n        dependencyRecomputations = 0\r\n      },\r\n      lastResult: () => lastResult,\r\n      recomputations: () => recomputations,\r\n      resetRecomputations: () => {\r\n        recomputations = 0\r\n      },\r\n      memoize,\r\n      argsMemoize\r\n    }) as OutputSelector<\r\n      InputSelectors,\r\n      Result,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    >\r\n  }\r\n  return createSelector as CreateSelectorFunction<\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  >\r\n}\r\n\r\n/**\r\n * Accepts one or more \"input selectors\" (either as separate arguments or a single array),\r\n * a single \"result function\" / \"combiner\", and an optional options object, and\r\n * generates a memoized selector function.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelector `createSelector`}\r\n *\r\n * @public\r\n */\r\nexport const createSelector =\r\n  /* #__PURE__ */ createSelectorCreator(weakMapMemoize)\r\n","import { createSelector } from 'reselect';\n\n\nexport const getUsersList = (state) => {\n  return state.usersPage.users;\n}\n\n// const getUsersFilter = (state) => { //Для примера применения реселекторов\n//   return getUsersList(state).filter(u => true)\n// }\n\nexport const getUserSuper = createSelector(getUsersList,(users) => {//Для примера применения реселекторов\n  return users.filter(u => true )\n});\n\nexport const getPageSize = (state) => {\n  return state.usersPage.pageSize;\n}\n\nexport const getTotalUserCount = (state) => {\n  return state.usersPage.totalUserCount;\n}\n\nexport const getCurrentPage = (state) => {\n  return state.usersPage.currentPage;\n}\n\nexport const getIsFetchingStatus = (state) => {\n  return state.usersPage.isFetching;\n}\n\nexport const getFollowingInProgress = (state) => {\n  return state.usersPage.followingInProgress;\n}\n\n","import { connect } from \"react-redux\";\nimport React from 'react';\nimport Users from './Users';\nimport Preloader from '../common/preloader/Preloader';\nimport { follow, unfollow, setCurrentPage, toggleFollowingProgress, getUsers } from \"../../redux/users-reducer\";\nimport { getUsersList, getCurrentPage, getFollowingInProgress, getIsFetchingStatus, getPageSize, getTotalUserCount } from \"../../redux/usesrs-selectors\";\n\nclass UsersContainer extends React.Component {\n\n    componentDidMount() {\n        this.props.getUsers(this.props.currentPage, this.props.pageSize);\n    }\n    onPageChanged = (page) => {\n        this.props.setCurrentPage(page)\n        this.props.getUsers(page, this.props.pageSize);\n    }\n    render() {\n\n        return <>\n            {this.props.isFetching ? <Preloader /> : null}\n            <Users\n                totalUserCount={this.props.totalUserCount}\n                pageSize={this.props.pageSize}\n                currentPage={this.props.currentPage}\n                users={this.props.users}\n                onPageChanged={this.onPageChanged}\n                unfollow={this.props.unfollow}\n                follow={this.props.follow} \n                followingInProgress={this.props.followingInProgress}\n            />\n        </>\n    }\n}\n\n\nconst mapStateToProps = (state) => {\n    return {\n        users: getUsersList(state),\n        pageSize: getPageSize(state),\n        totalUserCount: getTotalUserCount(state),\n        currentPage: getCurrentPage(state),\n        isFetching: getIsFetchingStatus(state),\n        followingInProgress: getFollowingInProgress(state),\n    }\n}\n\nexport default connect(\n    mapStateToProps,\n    {\n        follow, unfollow,\n        setCurrentPage,\n        toggleFollowingProgress, getUsers\n    })(UsersContainer);"],"names":["_ref","totalUserCount","pageSize","currentPage","onPageChanged","_ref$portionSize","portionSize","pagesCount","Math","ceil","pages","i","push","portionCount","_useState","useState","_useState2","_slicedToArray","portionNumber","setPortionNumber","leftPortionNumber","rightPortionNumber","_jsx","children","_jsxs","className","classes","onClick","filter","page","map","user","followingInProgress","follow","unfollow","NavLink","to","id","src","photos","small","userPhoto","alt","followed","disabled","some","name","status","props","_objectWithoutProperties","_excluded","Paginator","users","User","assertIsFunction","func","errorMessage","arguments","length","undefined","concat","TypeError","ensureIsArray","item","Array","isArray","getDependencies","createSelectorArgs","dependencies","array","every","itemTypes","join","assertIsArrayOfFunctions","Symbol","Object","getPrototypeOf","Ref","WeakRef","StrongRef","value","_classCallCheck","_createClass","key","this","UNTERMINATED","TERMINATED","createCacheNode","s","v","o","p","weakMapMemoize","lastResult","options","fnNode","resultEqualityCheck","resultsCount","memoized","cacheNode","l","arg","objectCache","WeakMap","objectNode","get","set","primitiveCache","Map","primitiveNode","result","terminatedNode","apply","_lastResult$deref","_lastResult","lastResultValue","deref","clearCache","resetResultsCount","createSelectorCreator","memoizeOrOptions","_len","memoizeOptionsFromArgs","_key5","createSelectorCreatorOptions","memoize","memoizeOptions","_len2","_key6","recomputations","dependencyRecomputations","directlyPassedOptions","resultFunc","pop","combinedOptions","_objectSpread","_combinedOptions$memo","_combinedOptions$args","argsMemoize","_combinedOptions$args2","argsMemoizeOptions","finalMemoizeOptions","devModeChecks","finalArgsMemoizeOptions","memoizedResultFunc","_toConsumableArray","selector","inputSelectorResults","inputSelectorArgs","collectInputSelectorResults","assign","resetDependencyRecomputations","resetRecomputations","createSelector","getUsersList","state","usersPage","getPageSize","u","getTotalUserCount","getCurrentPage","getIsFetchingStatus","isFetching","getFollowingInProgress","UsersContainer","_React$Component","_inherits","_super","_createSuper","_this","args","_key","call","setCurrentPage","getUsers","_Fragment","Preloader","Users","React","connect","toggleFollowingProgress"],"sourceRoot":""}